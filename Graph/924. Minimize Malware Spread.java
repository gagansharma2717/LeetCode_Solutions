https://leetcode.com/problems/minimize-malware-spread/

class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        HashSet<Integer> infectedNodes = new HashSet<>();
        int max = -1, resultNode = -1;
        int n = graph.length;
        boolean[] visited = new boolean[n];
        
//         We are sorting this array bcoz in case two nodes which are infecting the same amount 
//         of nodes so we will be able to return the smallest index node
        Arrays.sort(initial);
        
//         Adding Nodes of initial array in hashset
        for(int node : initial)
        {
            infectedNodes.add(node);
        }
         
        for(int i = 0 ; i < initial.length; i++)
        {
            if(!visited[initial[i]])
            {
//                 Remove the node from hashset to find if there is any other node in 
//                 that component which can infected other
                infectedNodes.remove(initial[i]);
                
                Pair ans = getConnectedComponents(initial[i],graph,visited,infectedNodes);

//                 This means is particular component m ther is no other node which can infect
//                 other nodes and also ans size is greater than max
                if(ans.containsInfectedNode == false && ans.size > max)
                {
                    max = ans.size;
                    resultNode = initial[i];
                }
                
                 infectedNodes.add(initial[i]);
            }
        }
        
//         This means if all the nodes which can infect other nodes are from same component then
//         return first node of initial array else return resultNode
        return resultNode == -1 ? initial[0] : resultNode;
    }
    
    class Pair{
        int size;
        boolean containsInfectedNode;
        
        Pair(int size, boolean containsInfectedNode)
        {
            this.size = size;
            this.containsInfectedNode = containsInfectedNode;
        }
    }
    
    public Pair getConnectedComponents(int src , int[][] graph , boolean[] visited, HashSet<Integer> infectedNodes){
        
        visited[src] = true;
        
//         Initially jo src contribute krega size obviously 1 node and if it is present in
//         hashset then true else false
        Pair ans = new Pair(1,infectedNodes.contains(src));
        
        for(int i = 0 ; i < graph.length; i++)
        {
            if(graph[src][i] == 1 && !visited[i])
            {
                Pair subAns = getConnectedComponents(i,graph,visited,infectedNodes);
                ans.containsInfectedNode = ans.containsInfectedNode || subAns.containsInfectedNode;
                ans.size += subAns.size;
            }
        }
        
        return ans;
    }
}
